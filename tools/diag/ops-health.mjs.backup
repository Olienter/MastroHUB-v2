#!/usr/bin/env node

import { spawn } from "child_process";
import { readFileSync, existsSync } from "fs";
import { join } from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = join(__filename, "..");

// Helper functions
function fileExists(p) {
  return existsSync(p);
}

function readJsonSafe(p) {
  try {
    return JSON.parse(readFileSync(p, "utf8"));
  } catch {
    return null;
  }
}

// Windows compatibility helpers
const isWin = process.platform === "win32";

function isCmdShim(p) {
  return /\.cmd$/i.test(p) || /\.bat$/i.test(p) || /\.ps1$/i.test(p);
}

// Quick verification without output
async function tryQuick(cmd, args = [], opts = {}) {
  try {
    const r = await execCmd(cmd, args, {
      ...opts,
      timeoutMs: 5000,
      tailLines: 5,
    });
    return r.exitCode === 0;
  } catch {
    return false;
  }
}

// Hint from env.output JSON
function hintFromEnv(envSection, binName) {
  try {
    if (!envSection || !envSection.output) return null;
    const parsed = JSON.parse(envSection.output);
    if (parsed?.[binName]?.path) return parsed[binName].path;
  } catch {}
  return null;
}

// where/which path lookup
async function whichBin(bin) {
  if (isWin) {
    const r = await execCmd("where", [bin], {
      shell: true,
      timeoutMs: 5000,
      tailLines: 10,
    });
    if (r.exitCode === 0) {
      const lines = (r.stdout || r.tail || "")
        .split(/\r?\n/)
        .map((s) => s.trim())
        .filter(Boolean);
      if (lines.length) return lines[0];
    }
  } else {
    const r = await execCmd("which", [bin], { timeoutMs: 5000, tailLines: 10 });
    if (r.exitCode === 0 && r.stdout) return r.stdout.trim();
  }
  return null;
}

// Main resolver with shell strategy
async function resolveBinPath(bin, { envSection } = {}) {
  // a) hint from env.output
  const hint = hintFromEnv(envSection, bin);
  if (hint) {
    const ok = await tryQuick(
      isWin && isCmdShim(hint) ? `"${hint}"` : hint,
      ["-v"],
      { shell: isWin && isCmdShim(hint) }
    );
    if (ok)
      return {
        cmd: isWin && isCmdShim(hint) ? `"${hint}"` : hint,
        useShell: isWin && isCmdShim(hint),
      };
  }

  // b) where/which
  const found = await whichBin(bin);
  if (found) {
    const useShell = isWin && isCmdShim(found);
    const cmd = useShell && !/^".*"$/.test(found) ? `"${found}"` : found;
    const ok = await tryQuick(cmd, ["-v"], { shell: useShell });
    if (ok) return { cmd, useShell };
  }

  // c) fallbacks for pnpm
  if (bin === "pnpm") {
    if (await tryQuick("corepack", ["pnpm", "-v"], { shell: true })) {
      return { cmd: "corepack pnpm", useShell: true };
    }
    if (await tryQuick("npx", ["pnpm", "-v"], { shell: true })) {
      return { cmd: "npx pnpm", useShell: true };
    }
  }

  // d) last resort: shell on Windows
  return { cmd: bin, useShell: isWin };
}

async function runBinResolved(bin, args = [], opts = {}, envSection = null) {
  const { cmd, useShell } = await resolveBinPath(bin, { envSection });
  return execCmd(cmd, args, { ...opts, shell: useShell });
}

const runPnpm = (args, opts, envSection) =>
  runBinResolved("pnpm", args, opts, envSection);
const runNpm = (args, opts, envSection) =>
  runBinResolved("npm", args, opts, envSection);

// pnpm execution with fallbacks
async function runPnpm(args, options = {}) {
  const pnpmBin = resolveBin("pnpm");

  try {
    // Try direct execution first
    return await execCmd(pnpmBin, args, {
      ...options,
      shell: process.platform === "win32",
    });
  } catch {
    // Fallback to corepack
    if (fileExists(join(process.cwd(), "node_modules", ".bin", "corepack"))) {
      return await execCmd("corepack", ["pnpm", ...args], {
        ...options,
        shell: process.platform === "win32",
      });
    }

    // Fallback to npx
    if (fileExists(join(process.cwd(), "node_modules", ".bin", "npx"))) {
      return await execCmd("npx", ["pnpm", ...args], {
        ...options,
        shell: process.platform === "win32",
      });
    }

    // Last resort - return MISSING status
    return {
      cmdline: `pnpm ${args.join(" ")}`,
      exitCode: -1,
      durationMs: 0,
      stdout: "",
      stderr: "pnpm not found",
      tail: "pnpm not found",
      status: "MISSING",
    };
  }
}

// npm execution with fallbacks
async function runNpm(args, options = {}) {
  const npmBin = resolveBin("npm");

  try {
    // Try direct execution first
    return await execCmd(npmBin, args, {
      ...options,
      shell: process.platform === "win32",
    });
  } catch {
    // Fallback to npx if available
    if (fileExists(join(process.cwd(), "node_modules", ".bin", "npx"))) {
      return await execCmd("npx", ["npm", ...args], {
        ...options,
        shell: process.platform === "win32",
      });
    }

    // Last resort - return MISSING status
    return {
      cmdline: `npm ${args.join(" ")}`,
      exitCode: -1,
      durationMs: 0,
      stdout: "",
      stderr: "npm not found",
      tail: "npm not found",
      status: "MISSING",
    };
  }
}

function readPackageJson() {
  const pkgPath = join(process.cwd(), "package.json");
  return readJsonSafe(pkgPath);
}

function hasScript(name) {
  const pkg = readPackageJson();
  return pkg?.scripts?.[name] ? true : false;
}

function hasDep(name) {
  const pkg = readPackageJson();
  return pkg?.dependencies?.[name] || pkg?.devDependencies?.[name]
    ? true
    : false;
}

function hasEslintConfig() {
  return (
    fileExists(".eslintrc") ||
    fileExists(".eslintrc.js") ||
    fileExists(".eslintrc.json") ||
    fileExists(".eslintrc.yaml") ||
    fileExists(".eslintrc.yml") ||
    readPackageJson()?.eslintConfig
  );
}

function execCmd(
  cmd,
  args = [],
  { cwd, env, timeoutMs = 300000, tailLines = 50 } = {}
) {
  return new Promise((resolve) => {
    const startTime = Date.now();
    let cmdline = `${cmd} ${args.join(" ")}`.trim();

    // pnpm fallback logic
    if (
      cmd === "pnpm" &&
      !fileExists(join(process.cwd(), "node_modules", ".bin", "pnpm"))
    ) {
      // Try corepack pnpm first
      if (fileExists(join(process.cwd(), "node_modules", ".bin", "corepack"))) {
        cmd = "corepack";
        args = ["pnpm", ...args];
        cmdline = `${cmd} ${args.join(" ")}`.trim();
      }
      // If still no corepack, try npx
      else if (fileExists(join(process.cwd(), "node_modules", ".bin", "npx"))) {
        cmd = "npx";
        args = ["pnpm", ...args];
        cmdline = `${cmd} ${args.join(" ")}`.trim();
      }
    }

    const child = spawn(cmd, args, {
      cwd: cwd || process.cwd(),
      env: { ...process.env, ...env },
      stdio: ["ignore", "pipe", "pipe"],
    });

    let stdout = "";
    let stderr = "";
    let timedOut = false;

    const timeout = setTimeout(() => {
      timedOut = true;
      child.kill("SIGTERM");
    }, timeoutMs);

    child.stdout.on("data", (data) => {
      stdout += data.toString();
    });

    child.stderr.on("data", (data) => {
      stderr += data.toString();
    });

    child.on("close", (exitCode) => {
      clearTimeout(timeout);
      const durationMs = Date.now() - startTime;

      if (timedOut) {
        resolve({
          cmdline,
          exitCode: -1,
          durationMs,
          stdout: "",
          stderr: "TIMEOUT",
          tail: "TIMEOUT",
          status: "TIMEOUT",
        });
        return;
      }

      const combined = stdout + "\n" + stderr;
      const lines = combined.split("\n").filter((line) => line.trim());
      const tail = lines.slice(-tailLines).join("\n");

      resolve({
        cmdline,
        exitCode,
        durationMs,
        stdout,
        stderr,
        tail,
        status: exitCode === 0 ? "OK" : "FAIL",
      });
    });

    child.on("error", (error) => {
      clearTimeout(timeout);
      const durationMs = Date.now() - startTime;
      resolve({
        cmdline,
        exitCode: -1,
        durationMs,
        stdout: "",
        stderr: error.message,
        tail: error.message,
        status: "ERROR",
      });
    });
  });
}

async function main() {
  const report = {
    meta: {},
    env: {},
    nodeTools: {},
    typecheck: {},
    eslint: {},
    build: {},
    mcp: {},
    envVars: {},
    summary: {},
  };

  // 1. Meta
  try {
    const gitResult = await execCmd("git", ["rev-parse", "--short", "HEAD"], {
      timeoutMs: 10000,
    });
    report.meta = {
      timestamp: new Date().toISOString(),
      head: gitResult.status === "OK" ? gitResult.stdout.trim() : "N/A",
    };
  } catch {
    report.meta = {
      timestamp: new Date().toISOString(),
      head: "N/A",
    };
  }

  // 2. Environment
  if (fileExists("tools/diag/verify-environment.mjs")) {
    try {
      const envResult = await execCmd(
        "node",
        ["tools/diag/verify-environment.mjs"],
        { timeoutMs: 60000 }
      );
      report.env = {
        status: envResult.status,
        exitCode: envResult.exitCode,
        durationMs: envResult.durationMs,
        output: envResult.stdout,
        error: envResult.stderr,
        tail: envResult.tail,
      };
    } catch {
      report.env = {
        status: "ERROR",
        exitCode: -1,
        durationMs: 0,
        output: "",
        error: "Execution failed",
        tail: "",
      };
    }
  } else {
    report.env = {
      status: "MISSING",
      exitCode: -1,
      durationMs: 0,
      output: "",
      error: "File not found",
      tail: "",
    };
  }

  // 3. Node Tools
  const nodeTools = {};

  // Node and Git (direct execution)
  try {
    const nodeResult = await execCmd("node", ["-v"], { timeoutMs: 10000 });
    nodeTools.node = {
      version: nodeResult.stdout.trim(),
      path: nodeResult.status === "OK" ? "OK" : "FAIL",
      status: nodeResult.status,
    };
  } catch {
    nodeTools.node = { version: "N/A", path: "FAIL", status: "ERROR" };
  }

  try {
    const gitResult = await execCmd("git", ["--version"], { timeoutMs: 10000 });
    nodeTools.git = {
      version: gitResult.stdout.trim(),
      path: gitResult.status === "OK" ? "OK" : "FAIL",
      status: gitResult.status,
    };
  } catch {
    nodeTools.git = { version: "N/A", path: "FAIL", status: "ERROR" };
  }

  // pnpm and npm (using new helpers)
  const pnpmResult = await runPnpm(["-v"], { timeoutMs: 10000 });
  nodeTools.pnpm = {
    version: pnpmResult.stdout.trim() || "N/A",
    path: pnpmResult.status === "OK" ? "OK" : "FAIL",
    status: pnpmResult.status,
  };

  const npmResult = await runNpm(["-v"], { timeoutMs: 10000 });
  nodeTools.npm = {
    version: npmResult.stdout.trim() || "N/A",
    path: npmResult.status === "OK" ? "OK" : "FAIL",
    status: npmResult.status,
  };

  report.nodeTools = nodeTools;

  // 4. Typecheck
  if (hasScript("typecheck")) {
    try {
      const result = await runPnpm(["run", "typecheck"], {
        timeoutMs: 120000,
      });
      report.typecheck = {
        status: result.status,
        exitCode: result.exitCode,
        durationMs: result.durationMs,
        tail: result.tail,
      };
    } catch {
      report.typecheck = {
        status: "ERROR",
        exitCode: -1,
        durationMs: 0,
        tail: "Execution failed",
      };
    }
  } else {
    report.typecheck = {
      status: "MISSING",
      exitCode: -1,
      durationMs: 0,
      tail: "Script not found",
    };
  }

  // 5. ESLint
  if (hasDep("eslint") || hasEslintConfig()) {
    try {
      const result = await runPnpm(
        ["exec", "eslint", ".", "--max-warnings=0", "-f", "unix"],
        { timeoutMs: 120000 }
      );
      const warningsCount =
        (result.stdout + result.stderr).toLowerCase().split("warning").length -
        1;
      report.eslint = {
        status: result.status,
        exitCode: result.exitCode,
        durationMs: result.durationMs,
        warningsCount: Math.max(0, warningsCount),
        tail: result.tail,
      };
    } catch {
      report.eslint = {
        status: "ERROR",
        exitCode: -1,
        durationMs: 0,
        warningsCount: 0,
        tail: "Execution failed",
      };
    }
  } else {
    report.eslint = {
      status: "SKIPPED",
      exitCode: -1,
      durationMs: 0,
      warningsCount: 0,
      tail: "Not configured",
    };
  }

  // 6. Build
  if (hasDep("next")) {
    try {
      const result = await runPnpm(["exec", "next", "build"], {
        env: { NEXT_TELEMETRY_DISABLED: "1" },
        timeoutMs: 300000,
      });
      const warningsCount =
        (result.stdout + result.stderr).split("Warning:").length - 1;
      report.build = {
        status: result.status,
        exitCode: result.exitCode,
        durationMs: result.durationMs,
        warningsCount: Math.max(0, warningsCount),
        tail: result.tail,
      };
    } catch {
      report.build = {
        status: "ERROR",
        exitCode: -1,
        durationMs: 0,
        warningsCount: 0,
        tail: "Execution failed",
      };
    }
  } else {
    report.build = {
      status: "SKIPPED",
      exitCode: -1,
      durationMs: 0,
      warningsCount: 0,
      tail: "Next.js not found",
    };
  }

  // 7. MCP
  if (hasScript("diag:mcp")) {
    try {
      const result = await runPnpm(["run", "diag:mcp"], {
        timeoutMs: 120000,
      });
      try {
        const mcpData = JSON.parse(result.stdout);
        report.mcp = {
          status: mcpData.summary?.status || "OK",
          exitCode: result.exitCode,
          durationMs: result.durationMs,
          data: mcpData,
          tail: result.tail,
        };
      } catch {
        report.mcp = {
          status: "UNKNOWN_FORMAT",
          exitCode: result.exitCode,
          durationMs: result.durationMs,
          rawTail: result.tail,
        };
      }
    } catch {
      report.mcp = {
        status: "ERROR",
        exitCode: -1,
        durationMs: 0,
        rawTail: "Execution failed",
      };
    }
  } else {
    report.mcp = {
      status: "MISSING",
      exitCode: -1,
      durationMs: 0,
      rawTail: "Script not found",
    };
  }

  // 8. Environment Variables
  const envFiles = [".env", ".env.local", ".env.production"];
  const envVars = {};

  for (const envFile of envFiles) {
    if (fileExists(envFile)) {
      try {
        const content = readFileSync(envFile, "utf8");
        const keys = content
          .split("\n")
          .map((line) => line.trim())
          .filter((line) => line && !line.startsWith("#"))
          .map((line) => line.split("=")[0])
          .filter((key) => key && /^[A-Z0-9_]+$/.test(key));

        envVars[envFile] = keys;

        // Check for important keys
        if (keys.includes("NEXT_PUBLIC_SITE_URL")) {
          envVars.hasNextPublicSiteUrl = true;
        }
        if (content.includes("DATABASE_URL")) {
          envVars.hasDatabaseUrl = true;
        }
      } catch {
        envVars[envFile] = ["ERROR_READING_FILE"];
      }
    }
  }
  report.envVars = envVars;

  // 9. Summary
  let summaryStatus = "OK";

  if (report.typecheck.status === "FAIL" || report.build.status === "FAIL") {
    summaryStatus = "FAIL";
  } else if (
    (report.build.status === "OK" && report.build.warningsCount > 0) ||
    (report.eslint.status === "OK" && report.eslint.warningsCount > 0) ||
    (report.mcp.status !== "OK" && report.mcp.status !== "MISSING")
  ) {
    summaryStatus = "WARN";
  }

  report.summary = {
    status: summaryStatus,
    timestamp: new Date().toISOString(),
    totalDurationMs: Object.values(report)
      .filter((item) => item.durationMs && typeof item.durationMs === "number")
      .reduce((sum, item) => sum + item.durationMs, 0),
  };

  // Output JSON
  console.log(JSON.stringify(report, null, 2));
}

main().catch((error) => {
  console.error("Ops health check failed:", error);
  process.exit(1);
});
